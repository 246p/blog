---
title: "3 1"
date: 2024-01-10T17:47:45+09:00
tags: ["Tag"]
draft: false
categories: ["2024"]
---
## Context-free grammar
CFG : defined with a set of production rules
ex) 
E -> E + E
E -> E * E
E -> id
E -> num

CFG : Derivation
ex) E â‡’ E + E â‡’ id + E â‡’ id + num
we will use â‡’* to denote arbitrary number of rewriting steps

CFG : Terminal Symbol : can't be rewritten anymore (+, *, id, num)
CFG : Non-Terminal Symbol : can be rewritten (E)

CFG : Sentence and Language
Sentence : Result of derivation that does not contain nay non-terminal
Language : set of all derivable sentences
           ğ‘³(ğ‘®) = {ğ’˜ | ğ‘ºâ‡’ âˆ—ğ’˜, ğ’˜ consists of terminals}

Leftmost Derivation : derivationì„ í• ë•Œ ê°€ì¥ ì™¼ìª½ì˜ non-terminal ì„ ë³€í™˜

Derivation processì¤‘ Parse treeë¥¼ ë§Œë“¤ ìˆ˜ ìˆìŒ
ex) E â‡’ E + E â‡’ id + E â‡’ id + num





RegEx vs CFG
R = ((id | num) (' + ' | ' * '))* (id | num) ì™€ ê°™ì´ RegExë¡œ í‘œí˜„ ê°€ëŠ¥
í•˜ì§€ë§Œ brackets : "{}", "{{}}", {{{}}}",... ê³¼ ê°™ì´ RegExë¡œ í‘œí˜„ ë¶ˆê°€ëŠ¥í•œ ê²ƒì´ ì¡´ì¬
ë˜í•œ RegExëŠ” Parse Treeë¥¼ ìƒì„±í•  ìˆ˜ ì—†ìŒ

Ambiguous Grammar
ë‹¤ìŒê³¼ ê°™ì€ ê²½ìš° ì—¬ëŸ¬ê°€ì§€ ë°©ë²•ìœ¼ë¡œ ë³€í™˜ì´ ë¨

















ìš°ë¦¬ëŠ” ì´ë¥¼ ë°©ì§€í•˜ê¸° ìœ„í•˜ì—¬ ë‘ê°€ì§€ ë¬¸ì œë¥¼ í•´ê²°í•´ì•¼í•œë‹¤.
1) Eliminate ambiguity
2) (Precedence) Bind * before +
- id + id * id must be interpreted as id + (id * id)
3) (Associativity) * and + associate to the left
- id + id + id must be interpreted as (id + id) + id

> ë‹¤ìŒê³¼ ê°™ì´ CFGë¥¼ ì •ì˜í•˜ë©´ ê°€ëŠ¥í•˜ë‹¤.
Start variable is E
E -> E + T | T
T -> T * F | F
F -> id | num



General Rewriting Algorithm? 
ambiguous -> unambiguousë¡œ rewriteí•˜ëŠ” algorithm ì€ ì—†ìŒ
ì‹¬ì§€ì–´ ambiguous í•œì§€ íŒë‹¨í•˜ëŠ” algorithm ë˜í•œ ì—†ìŒ
- Undecidable problem
ìš°ë¦¬ëŠ” ì•ìœ¼ë¡œ unambiguous í•˜ë‹¤ëŠ” ê°€ì •í•˜ì— í’€ì–´ê°

##Top-down parsing
ParserëŠ” derivationì„ ì¶”ë¡ í•´ì•¼í•¨ (if exist)
- Parsing is the process of inferring derivation for the token stream
- construction of parse tree

Top-down parsing
- leftmost derivations
- root nodeì—ì„œ ì•„ë˜ ë°©í–¥ìœ¼ë¡œ ëŠ˜ë ¤ì•¼í•¨

At each step, we must rewrite the left most non-terminal
- ì´ë•Œ ì–´ë– í•œ production ruleì„ ì‚¬ìš©í• ì§€ ê³¨ë¼ì•¼í•¨
parsing table : caseì— ë”°ë¼ ì–´ë–¤ ruleì„ ì‚¬ìš©í• ì§€ ì•Œë ¤ì¤Œ
- current status + next tokenì„ í†µí•´ ê³ ë¥¼ ìˆ˜ ìˆìŒ
- table drivven LL(1) parsing or LL(1) parsing
    - Left-to-right, Leftmost derivation, 1 token lookahead

### LL(1) Grammar
ëª¨ë“  CFGì— ëŒ€í•´ì„œ ì ìš©í•  ìˆ˜ ì—†ìŒ
- ì–´ë–¤ grammarë“¤ì€ parsing tableì„ ë§Œë“¤ ìˆ˜ ì—†ìŒ

LL(1) Grammar : LL(1) parsingì´ ì ìš© ë˜ëŠ” CFG

ë‹¤ìŒ CFGëŠ” LL(1)ì´ ì•„ë‹˜
E -> E + T | T
T -> T * F | F
F -> id | num

### Left-Recursion
 - CFG has a variable A that appear as the fist symbol in right-hand side of a rule
ìœ„ ì˜ˆì‹œì—ì„œ E, TëŠ” left-recursive
CFGê°€ left-recursiveì´ë©´ LL(1)ì´ ë  ìˆ˜ ì—†ìŒ

Eliminating Left-Recursion
ğ‘¨ â†’ ğ‘¨ğœ¶ | ğœ· 
ìœ„ì™€ ê°™ì€ ruleì„ ë‹¤ìŒê³¼ rewriteí•  ìˆ˜ ìˆë‹¤.
ğ‘¨ â†’ ğœ·ğ‘¨â€²
ğ‘¨â€² â†’ ğœ¶ğ‘¨â€² | ğ
ì´ë¥¼ ìš°ë¦¬ì˜ production ruleì— ì ìš©í•´ ë³´ì






Left-recursionì´ ë˜ì§€ ì•ŠìŒì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤.

Left- Recursion ì´ ì•„ë‹ˆë”ë¼ë„ ê¼­ LL(1)ëŠ” ì•„ë‹ˆë‹¤.
* ìš´ì´ ì¢‹ê²Œë„ ìš°ë¦¬ì˜ CFGëŠ” LL(1)ì´ ë§ë‹¤.

### LL(1) Parsing Example
LL(1) parsing process for num + id
stackì„ ì´ìš©í•œë‹¤. ì•„ë˜ì—ì„œ $ëŠ” special marker(terminal)ì„ ì˜ë¯¸í•œë‹¤.
|            Stack  |     Input Tokens |  Rule       |
|---------------:|-----------------:|---------------:|
|               E $ |         num + id $ |                    |
|           T E' $ |         num + id $ |  E -> T E'       |
|         F T' E' $ |        num + id $ | T -> F T'        | 
|      num T' E' $ |        num + id $ | F -> num         |
|           T' E' $ |              + id $ | Match and Pop  |
|               E' $ |              + id $ | T' -> ğœº           |
|          + T E' $ |              + id $ | E' -> + T E;     |
|            T E' $ |                id $ | Match and Pop  |
|         F T' E' $ |                id $ | T -> F T'        |
|         id T' E' $ |                id $ | F -> id           |
|            T' E' $ |                   $ | Match and Pop |
|               E' $ |                   $ | T' -> ğœº           |
|                  $ |                   $ | E' -> ğœº           | 



Parsing Table Example 
Row : non-terminal on stack top
Column : first terminal (token) in buffer








### First() and Follow()
Parsing tableì„ ë§Œë“¤ë•Œ First, Follow setì„ ë¨¼ì € ë§Œë“¤ì–´ì•¼í•¨
First(a) : aë¥¼ íŒŒìƒí•˜ì—¬ ë‚˜ì˜¬ ìˆ˜ ìˆëŠ” ë¬¸ì¥ ì¤‘ ì²« ë¬¸ìë“¤ì˜ ì§‘í•©
Follow(X) : Xë¥¼ íŒŒìƒí•˜ì—¬ ë‚˜ì˜¨ ë¬¸ì¥ ë¬¸ì¥ ì´í›„ ë‚˜ì˜¬ ìˆ˜ ìˆëŠ” ë¬¸ì ë“¤ì˜ ì§‘í•©









### Building Parsing Table 
X -> a 
- for t in First (a), add X -> a to the parsing table in Tap [X, t]
- if ğœº is in First (a), for t in Follow (x), add X -> a to Tap [X, t] 










construction fail 
Consider X -> a1 | ... | an
if First (ai)ê°€ disjoint í•˜ì§€ ì•Šì„ ê²½ìš° tableì˜ í•˜ë‚˜ì˜ slotì— ì—¬ëŸ¬ ruleì´ ë“¤ì–´ê°
- invalid parsing table
- CFGê°€ LL(1) Grammarê°€ ì•„ë‹ˆë¼ëŠ” ì˜ë¯¸




